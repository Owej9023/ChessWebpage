---
title: "Untitled"
author: "Owen Dy"
date: "2024-06-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
library(shiny)
library(httr)
library(jsonlite)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(hms)
library(plotly)
library(htmltools)
library(stringr)


# Function to extract values from the PGN string
extract_pgn_values <- function(pgn, num_values = 21) {
  input_text <- paste(pgn, collapse = " ")
  matches <- str_extract_all(input_text, "\\[(.*?)\\]")[[1]][1:num_values]
  return(matches)
}

# Function to clean date values
clean_dates <- function(dates) {
  return(as.Date(gsub("\\[Date \"|\"\\]", "", dates), format = "%Y.%m.%d"))
}

# Function to clean result values
clean_results <- function(results) {
  return(regmatches(results, regexpr("\\d+/\\d+-\\d+/\\d+|\\d+-\\d+", results))[[1]])
}

# Function to clean Elo values
clean_elo <- function(elo) {
  return(as.numeric(gsub("\\D", "", elo)))
}

# Function to clean time values
clean_time <- function(time) {
  return(hms::as_hms(regmatches(time, regexpr("\\d{2}:\\d{2}:\\d{2}", time))[[1]]))
}

# Function to clean usernames
clean_usernames <- function(user_string) {
  return(sub("\\[.*?\"(.*?)\"\\]", "\\1", user_string))
}


chess_username <- "Owej9023"
desired_rows <- 500000
game_types <- c("Rapid", "Blitz", "Bullet")
api_url <- paste0("https://api.chess.com/pub/player/", chess_username, "/games/archives")
```

```{r}
# Fetch and parse archive URLs
archives <- jsonlite::fromJSON(content(GET(api_url), "text"))

# Initialize progress bar
#progress <- shiny::Progress$new()
#progress$set(message = "Fetching data", value = 0)
#on.exit(progress$close())

# Fetch and combine game data from all archives
archive_data <- list()
total_archives <- length(archives$archives)

for (i in seq_along(archives$archives)) {
  archive_data[[i]] <- jsonlite::fromJSON(content(GET(archives$archives[i]), "text", flatten = TRUE))
  #progress$inc(1 / total_archives, detail = paste("Processing archive", i, "of", total_archives))
}

combined_df <- bind_rows(archive_data) %>%
  filter(grepl(paste(game_types, collapse = "|"), games$time_class, ignore.case = TRUE),
         games$rules == "chess", 
         games$rated == TRUE)

# Extract values from PGN strings and include ChessGameType
result_list <- lapply(seq_len(nrow(combined_df$games)), function(i) {
  pgn_values <- extract_pgn_values(combined_df$games$pgn[i])
  pgn_values <- as.data.frame(t(pgn_values), stringsAsFactors = FALSE)
  pgn_values$ChessGameType <- combined_df$games$time_class[i]
  return(pgn_values)
})

result_df <- bind_rows(result_list) %>% na.omit()

if (desired_rows < nrow(result_df)) {
  result_df <- tail(result_df, desired_rows)
}

result_df$V3 <- clean_dates(result_df$V3)
result_df$V3 <- as.Date(result_df$V3)
result_df$V7 <- sapply(result_df$V7, clean_results)
result_df[, c(14, 15)] <- sapply(result_df[, c(14, 15)], clean_elo)
result_df$V16 <- sapply(result_df$V16, clean_elo)
result_df[, c(18, 20)] <- lapply(result_df[, c(18, 20)], clean_time)
result_df[, c(5, 6)] <- sapply(result_df[, c(5, 6)], clean_usernames)

result_df$elo_change <- NA
result_df$total_elo_change <- NA

for (i in 1:nrow(result_df)) {
  if (result_df[i, "V5"] == chess_username) {
    current_elo <- result_df[i, "V14"]
    opponent_elo <- result_df[i, "V15"]
  } else if (result_df[i, "V6"] == chess_username) {
    current_elo <- result_df[i, "V15"]
    opponent_elo <- result_df[i, "V14"]
  } else {
    next
  }
  
  if (i == 1) {
    result_df[i, "elo_change"] <- 0
  } else {
    previous_elo <- ifelse(result_df[i - 1, "V5"] == chess_username, 
                           result_df[i - 1, "V14"], 
                           result_df[i - 1, "V15"])
    elo_change <- current_elo - previous_elo
    result_df[i, "elo_change"] <- elo_change
  }
}

result_df$total_elo_change <- ave(result_df$elo_change, result_df$V3, FUN = cumsum)
result_df$elo_change[is.na(result_df$elo_change)] <- 0

result_df <- result_df %>%
  group_by(V3) %>%
  mutate(total_elo_change = last(total_elo_change)) %>%
  ungroup() %>%
  mutate(
    day_of_week = factor(weekdays(V3), levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")),
    chess_username = ifelse(chess_username %in% c(V5, V6), as.numeric(ifelse(chess_username %in% V5, V14, V15)), NA_real_),
    hour = hour(V18),
    hourend = hour(V20),
    game_number = row_number(),
    game_type = result_df$ChessGameType
  ) %>%
  select(-V17, -V21)

result_df$year <- year(result_df$V3)
result_df$week <- week(result_df$V3)
result_df$month <- month(result_df$V3)

summary_week <- result_df %>%
  group_by(year, week, game_type) %>%
  summarize(
    mean_week_elo = mean(total_elo_change, na.rm = TRUE),
    sd_week_elo = sd(total_elo_change, na.rm = TRUE),
    count = n(),
    sem_week_elo = sd(total_elo_change, na.rm = TRUE) / sqrt(n())
  )

summary_month <- result_df %>%
  group_by(year, month, game_type) %>%
  summarize(
    mean_month_elo = mean(total_elo_change, na.rm = TRUE),
    sd_month_elo = sd(total_elo_change, na.rm = TRUE),
    count = n(),
    sem_month_elo = sd(total_elo_change, na.rm = TRUE) / sqrt(n())
  )

summary_year <- result_df %>%
  group_by(year, game_type) %>%
  summarize(
    mean_year_elo = mean(total_elo_change, na.rm = TRUE),
    sd_year_elo = sd(total_elo_change, na.rm = TRUE),
    count = n(),
    sem_year_elo = sd(total_elo_change, na.rm = TRUE) / sqrt(n())
  )

```

```{r}
library(plotly)
library(httr)
library(dplyr)
library(shiny)
library(stringr)
library(tidyr)
library(ggplot2)
library(chron)
library(scales)
library(lubridate)
library(bigchess)

filtered_data <- combined_df %>% filter(games$rules == "chess")
filtered_data <- filtered_data %>% filter(games$rated == "TRUE")

# Create a function that calculates the amount of time spent per move
subtract_time <- function(set_value, variable) {
  set_time <- as.POSIXct(set_value, format = "%M:%OS")
  set_time <- as.numeric(set_time)
  variable_time <- as.POSIXct(variable, format = "%M:%OS")
  variable_time <- as.numeric(variable_time)
  # Subtract the variable time from the set time
  result_time <- set_time - variable_time

  # Return the result time
  return(result_time)
}

# Initialize lists and counters
timepermove <- list()
count <- 0

# Loop through each game in combined_df
for (value in combined_df$games$time_control) {
  # Split the string based on the '+'
  split_strings <- strsplit(value, "\\+")[[1]]
  
  # Extract the length of the game for each player in minutes
  Length_of_Game_For_Each_Player <- as.numeric(split_strings[1])
  
  # Convert minutes to HH:MM format
  time_in_hhmm <- sprintf("%02d:%02d", Length_of_Game_For_Each_Player %/% 60, Length_of_Game_For_Each_Player %% 60)
  
  # Set 'set_value' to the formatted time
  set_value <- time_in_hhmm
  
  # Initialize a list to store time per move within the outer loop
  timepermoveinterior <- list()
  
  # Extract all matches of time values in the 'value'
  count <- count + 1
  matches <- str_extract_all(filtered_data$games$pgn[count], '\\d+:\\d+(?:\\.\\d+|)]')[[1]]
  set_value <- time_in_hhmm
  set_value1 <- time_in_hhmm
  
  
  # Get the time_class for the current game
  current_time_class <- filtered_data$games$time_class[count]
  
  for (move in 1:length(matches)) {
    if (move %% 2 == 0) {
      m2 <- as.character(matches[move])
      # Convert the string to POSIXct format (minutes and seconds)
      NewMatches <- as.POSIXct(m2, format = "%M:%OS")
      # Calculate time remaining using a custom function 'subtract_time'
      timeRemaining <- subtract_time(set_value, NewMatches)
      # Update 'set_value' for the next iteration
      set_value <- m2
      # Round the time remaining to one decimal place and add it to the interior list
      timeRemaining <- round(timeRemaining, digits = 1)
      timepermoveinterior <- c(timepermoveinterior, timeRemaining)
    } else {
      if (move == 1) {
        m1 <- set_value1
      } else {
        m1 <- as.character(matches[move])
      }
      # Convert the string to POSIXct format (minutes and seconds)
      NewMatches1 <- as.POSIXct(m1, format = "%M:%OS")
      # Calculate time remaining using a custom function 'subtract_time'
      timeRemaining <- subtract_time(set_value1, NewMatches1)
      # Update 'set_value1' for the next iteration
      set_value1 <- m1
      # Round the time remaining to one decimal place and add it to the interior list
      timeRemaining <- round(timeRemaining, digits = 1)
      timepermoveinterior <- c(timepermoveinterior, timeRemaining)
    }
  }
  
  # Add time_per_move and time_class for the current game to the respective lists
  timepermove <- c(timepermove, list(timepermoveinterior))
}

# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
  inner_list <- timepermove[[list_num]]
  if (length(inner_list) > 0) {
    df <- data.frame(
      time_per_move = unlist(inner_list),
      Move_Number = seq_along(inner_list),
      game_number = list_num,
      time_class = rep(filtered_data$games$time_class[list_num], length(inner_list))
    )
    return(df)
  } else {
    return(NULL)
  }
}))


```

#original timestamp code
```{r}
# Use the provided functions to extract and separate moves and timestamps
extract_moves_and_timestamps <- function(pgn) {
  lines <- unlist(strsplit(pgn, "\n"))
  moves_line <- lines[length(lines)]
  matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
  moves <- unlist(matches)
  moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
  return(moves_cleaned)
}

separate_moves_and_timestamps <- function(data) {
  moves <- c()
  timestamps <- list()
  for (entry in data) {
    if (grepl("^\\d+\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
    } else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
    } else {
      next
    }
    timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
    moves <- c(moves, move)
    timestamps <- c(timestamps, timestamp)
  }
  move_string <- paste(moves, collapse = " ")
  timestamp_dict <- as.list(timestamps)
  return(list(moves = moves, timestamps = timestamp_dict))
}

# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0

# Loop through each game in combined_df
for (pgn in combined_df$games$pgn[1]) {
  count <- count + 1
  
  # Extract moves and timestamps from the PGN data
  extracted_data <- extract_moves_and_timestamps(pgn)
  separated_data <- separate_moves_and_timestamps(extracted_data)
  
  # Extract the moves and timestamps
  moves <- separated_data$moves
  timestamps <- separated_data$timestamps
  
  # Initialize a list to store time per move within the outer loop
  timepermoveinterior <- list()
  movesinterior <- list()
  
  # Convert timestamps to numeric and calculate time per move
  previous_time <- as.numeric(as.POSIXct("00:00", format="%M:%S"))
  for (i in seq_along(timestamps)) {
    current_time <- as.numeric(as.POSIXct(timestamps[[i]], format="%M:%S"))
    time_per_move <- round(previous_time - current_time, 1)
    timepermoveinterior <- c(timepermoveinterior, time_per_move)
    movesinterior <- c(movesinterior, moves[i])
    previous_time <- current_time
  }
  
  # Add time_per_move, move, and time_class for the current game to the respective lists
  timepermove <- c(timepermove, list(timepermoveinterior))
  moves_list <- c(moves_list, list(movesinterior))
}

# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
  inner_list <- timepermove[[list_num]]
  move_list <- moves_list[[list_num]]
  if (length(inner_list) > 0) {
    df <- data.frame(
      time_per_move = unlist(inner_list),
      Move_Number = seq_along(inner_list),
      game_number = list_num,
      time_class = rep(filtered_data$games$time_class[list_num], length(inner_list)),
      Move = unlist(move_list)
    )
    return(df)
  } else {
    return(NULL)
  }
}))


```
#experemental timestamp code
#
```{r}
extract_moves_and_timestamps <- function(pgn) {
  lines <- unlist(strsplit(pgn, "\n"))
  moves_line <- lines[length(lines)]
  matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
  moves <- unlist(matches)
  moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
  return(moves_cleaned)
}

separate_moves_and_timestamps <- function(data) {
  moves <- c()
  timestamps <- list()
  for (entry in data) {
    if (grepl("^\\d+\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
    } else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
    } else {
      next
    }
    timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
    moves <- c(moves, move)
    timestamps <- c(timestamps, timestamp)
  }
  move_string <- paste(moves, collapse = " ")
  timestamp_dict <- as.list(timestamps)
  return(list(moves = moves, timestamps = timestamp_dict))
}

# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0

# Loop through each game in combined_df
library(lubridate)
library(hms)  # For handling time without dates

# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0

# Loop through each game in combined_df
for (pgn in combined_df$games$pgn[1]) {
  count <- count + 1
  
  # Extract moves and timestamps from the PGN data
  extracted_data <- extract_moves_and_timestamps(pgn)
  separated_data <- separate_moves_and_timestamps(extracted_data)
  
  # Extract the moves and timestamps
  moves <- separated_data$moves
  timestamps <- separated_data$timestamps
  
  # Initialize a list to store time per move within the outer loop
  timepermoveinterior <- list()
  movesinterior <- list()

  # Initialize the previous time with the starting time control in seconds
  # Convert time control (e.g., 600, 180) to an hms object
  initial_time <- as.numeric(combined_df$games$time_control[count])
  previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
  
  # Loop through timestamps to calculate time per move
  for (i in seq_along(timestamps)) {
    # Convert the current timestamp to an hms object
    current_time <- as_hms(timestamps[[i]])
    print(current_time)
    # Calculate the time per move in seconds (including milliseconds)
    time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
    print(time_per_move)
    # Round the time per move to 1 decimal place and store it
    time_per_move <- round(time_per_move, 1)
    timepermoveinterior <- c(timepermoveinterior, time_per_move)
    
    # Store the move
    movesinterior <- c(movesinterior, moves[i])
    
    # Update previous time for the next iteration
    previous_time <- current_time
  }
  
  # Add time_per_move, move, and time_class for the current game to the respective lists
  timepermove <- c(timepermove, list(timepermoveinterior))
  moves_list <- c(moves_list, list(movesinterior))
}

# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
  inner_list <- timepermove[[list_num]]
  move_list <- moves_list[[list_num]]
  if (length(inner_list) > 0) {
    df <- data.frame(
      time_per_move = unlist(inner_list),
      Move_Number = seq_along(inner_list),
      game_number = list_num,
      time_class = rep(filtered_data$games$time_class[list_num], length(inner_list)),
      Move = unlist(move_list)
    )
    return(df)
  } else {
    return(NULL)
  }
}))



```

#Updated Timestamp
```{r}
library(lubridate)
library(hms)  # For handling time without dates
library(utils)  # For txtProgressBar

extract_moves_and_timestamps <- function(pgn) {
  lines <- unlist(strsplit(pgn, "\n"))
  moves_line <- lines[length(lines)]
  matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
  moves <- unlist(matches)
  moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
  return(moves_cleaned)
}

separate_moves_and_timestamps <- function(data) {
  moves <- c()
  timestamps <- list()
  for (entry in data) {
    if (grepl("^\\d+\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
    } else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
    } else {
      next
    }
    timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
    moves <- c(moves, move)
    timestamps <- c(timestamps, timestamp)
  }
  move_string <- paste(moves, collapse = " ")
  timestamp_dict <- as.list(timestamps)
  return(list(moves = moves, timestamps = timestamp_dict))
}

# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0

# Create a progress bar
total_games <- nrow(combined_df$games)
progress_bar <- txtProgressBar(min = 0, max = total_games, style = 3)

# Loop through each game in combined_df
for (pgn in combined_df$games$pgn) {
  count <- count + 1
  
  # Extract moves and timestamps from the PGN data
  extracted_data <- extract_moves_and_timestamps(pgn)
  separated_data <- separate_moves_and_timestamps(extracted_data)
  
  # Extract the moves and timestamps
  moves <- separated_data$moves
  timestamps <- separated_data$timestamps
  
  # Initialize a list to store time per move within the outer loop
  timepermoveinterior <- list()
  movesinterior <- list()
  
  # Initial time controls for each player (in seconds)
  initial_time <- as.numeric(strsplit(combined_df$games$time_control[count], "\\+")[[1]][1])
  white_previous_time <- as_hms(initial_time)
  black_previous_time <- as_hms(initial_time)
  
  # Loop through timestamps to calculate time per move, tracking each player's clock separately
  for (i in seq_along(timestamps)) {
    current_move <- moves[i]
    current_timestamp <- as_hms(timestamps[[i]])
    
    if (i %% 2 == 1) {  # Odd index means it's White's move
      time_per_move <- as.numeric(difftime(white_previous_time, current_timestamp, units = "secs"))
      white_previous_time <- current_timestamp
    } else {  # Even index means it's Black's move
      time_per_move <- as.numeric(difftime(black_previous_time, current_timestamp, units = "secs"))
      black_previous_time <- current_timestamp
    }
    
    # Round the time per move to 1 decimal place and store it
    time_per_move <- round(time_per_move, 1)
    timepermoveinterior <- c(timepermoveinterior, time_per_move)
    
    # Store the move
    movesinterior <- c(movesinterior, current_move)
  }
  
  # Add time_per_move, move, and time_class for the current game to the respective lists
  timepermove <- c(timepermove, list(timepermoveinterior))
  moves_list <- c(moves_list, list(movesinterior))

  # Update the progress bar
  setTxtProgressBar(progress_bar, count)
}

# Close the progress bar
close(progress_bar)

# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
  inner_list <- timepermove[[list_num]]
  move_list <- moves_list[[list_num]]
  if (length(inner_list) > 0) {
    df <- data.frame(
      time_per_move = unlist(inner_list),
      Move_Number = seq_along(inner_list),
      game_number = list_num,
      time_class = rep(combined_df$games$time_class[list_num], length(inner_list)),
      Move = unlist(move_list)
    )
    return(df)
  } else {
    return(NULL)
  }
}))


library(chess)
library(bigchess)
library(stockfish)
# Analyze moves using Stockfish

stockfish_path <- "/Program Files (x86)/Tarrasch/Engines/stockfish_11_x64"
```

```{r}
# Sample PGN data
pgn_data <- filtered_data$games$pgn

# Extract moves and timestamps
extract_moves_and_timestamps <- function(pgn) {
  # Split the PGN data by newline
  lines <- unlist(strsplit(pgn, "\n"))
  
  # Find the line containing the moves (last line in this case)
  moves_line <- lines[length(lines)]
  
  # Extract moves and timestamps using regex for both White and Black moves
  matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
  moves <- unlist(matches)
  
  # Clean up the extracted moves and timestamps
  moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
  
  return(moves_cleaned)
}

# Get the cleaned moves and timestamps
moves_and_timestamps <- extract_moves_and_timestamps(pgn_data)
print(moves_and_timestamps)


# Function to separate moves and timestamps
separate_moves_and_timestamps <- function(data) {
  # Initialize empty lists for moves and timestamps
  moves <- c()
  timestamps <- list()
  
  # Loop through each entry in the data
  for (entry in data) {
    # Extract move
    if (grepl("^\\d+\\.\\s+", entry)) {
      # White move format: number followed by dot and space
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
    } else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
      # Black move format: number followed by three dots and space
      move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
    } else {
      next  # Skip entries that don't match move patterns (e.g., headers)
    }
    
    # Extract timestamp
    timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
    
    # Append to lists
    moves <- c(moves, move)
    timestamps <- c(timestamps, timestamp)
  }
  
  # Concatenate moves into a single string
  move_string <- paste(moves, collapse = " ")
  
  # Convert timestamps to a named list
  timestamp_dict <- as.list(timestamps)
  
  return(list(moves = move_string, timestamps = timestamp_dict))
}

moves_and_timestamps_scholars_mate <- c(
  "1. e4 {[%clk 0:09:59.7]",
  "1... e5 {[%clk 0:09:58.6]",
  "2. Qh5 {[%clk 0:09:56.3]",
  "2... Nc6 {[%clk 0:09:56.1]",
  "3. Bc4 {[%clk 0:09:51.5]",
  "3... Nf6 {[%clk 0:09:46.6]",
  "4. Qxf7# {[%clk 0:09:32.7]"
)
# Get the cleaned moves and timestamps
temp <- separate_moves_and_timestamps(moves_and_timestamps)


```

#using python to get an accurate score for the position

```{python}
import chess
import chess.engine
move_scores = []
def analyze_each_move(moves_str, depth=20, stockfish_path="/path/to/stockfish"):
    # Initialize the Stockfish engine
    with chess.engine.SimpleEngine.popen_uci(stockfish_path) as engine:
        # Set up the board
        board = chess.Board()
        
        # Split the moves string into individual moves
        moves = moves_str.split()
        
        # Store the scores for each move
        
        # Play and analyze each move
        for move in moves:
            # Play the move on the board
            board.push_san(move)
            
            # Analyze the current position
            info = engine.analyse(board, chess.engine.Limit(depth=depth))
            # Check if the position results in a mate
            mate_in = info["score"].relative.mate()
            if mate_in is not None:
                # If it's a mate, use a large score value
                score = 10000 * (mate_in / abs(mate_in))
            else:
                # Otherwise, use the centipawn score
                score = info["score"].relative.score() / 100
                
            # Adjust the score based on whose turn it is
            if board.turn == chess.BLACK:
                score = -score
                
            # Append the score and the move to the list
            move_scores.append((move, score))
            
        return move_scores


```





#first working reticulate score analysis

```{r}
rm(results_df_scorea)
# Split the PGN data into separate games
pgn_list <- strsplit(combined_df$games$pgn, "\n\n")

# Initialize lists to store moves and timestamps
all_moves <- list()
all_timestamps <- list()

# Loop through each game and extract moves and timestamps
for (i in seq_along(pgn_list)) {
  game_pgn <- pgn_list[[i]]
  
  # Extract moves and timestamps for the current game
  temp_aa <- extract_moves_and_timestamps(game_pgn)
  temp_aa <- separate_moves_and_timestamps(temp_aa)
  
  # Store the results in the lists
  all_moves[[i]] <- temp_aa$moves
  all_timestamps[[i]] <- temp_aa$timestamps
}

library(reticulate)
py_run_string("
import chess
import chess.engine
move_scores = []
def analyze_each_move(moves_str, depth=20, stockfish_path='/path/to/stockfish'):
    # Initialize the Stockfish engine
    with chess.engine.SimpleEngine.popen_uci(stockfish_path) as engine:
        # Set up the board
        board = chess.Board()
        
        # Split the moves string into individual moves
        moves = moves_str.split()
        
        # Store the scores for each move
        
        # Play and analyze each move
        for move in moves:
            # Play the move on the board
            board.push_san(move)
            
            # Analyze the current position
            info = engine.analyse(board, chess.engine.Limit(depth=depth))
            # Check if the position results in a mate
            mate_in = info['score'].relative.mate()
            if mate_in is not None:
              if mate_in == 0:
                score = 10000  # or another appropriate value for immediate mate
              else:
                score = 10000 * (mate_in / abs(mate_in))
            else:
              # Otherwise, use the centipawn score
              score = info['score'].relative.score() / 100
                
            # Adjust the score based on whose turn it is
            if board.turn == chess.BLACK:
                score = -score
                
            # Append the score and the move to the list
            move_scores.append((move, score))
            
        return move_scores
")

```



```{r}
# Initialize an empty list to store combined data for each game
combined_data <- list()

# Loop through each game and combine moves and timestamps into a data frame
for (i in seq_along(all_moves)) {
  # Get moves and timestamps for the current game
  moves <- all_moves[[i]]
  timestamps <- all_timestamps[[i]]
  
  # Check if the number of moves and timestamps are equal
  if (length(moves) == length(timestamps)) {
    # Extract only the timestamp from the format {[%clk 0:09:59.7]}
    cleaned_timestamps <- gsub(".*\\{\\[%clk\\s+([^\\}]+)\\]\\}", "\\1", timestamps)
    
    # Create a data frame for the current game with moves and cleaned timestamps
    game_data <- data.frame(
      Move = moves,
      Timestamp = cleaned_timestamps,
      stringsAsFactors = FALSE
    )
  } else {
    # Handle the case where moves and timestamps are not equal
    warning(paste("Mismatch between moves and timestamps for game", i))
    
    # To avoid error, truncate the longer list to match the shorter one
    min_length <- min(length(moves), length(timestamps))
    
    # Extract only the timestamp from the format {[%clk 0:09:59.7]}
    cleaned_timestamps <- gsub(".*\\{\\[%clk\\s+([^\\}]+)\\]\\}", "\\1", timestamps[1:min_length])
    
    # Create a data frame with the truncated moves and cleaned timestamps
    game_data <- data.frame(
      Move = moves[1:min_length],
      Timestamp = cleaned_timestamps,
      stringsAsFactors = FALSE
    )
  }
  
  # Add the game data frame to the combined list
  combined_data[[i]] <- game_data
}
```


```{r}
# Set the number of games to analyze
NumberOfGames <- 3  # Adjust this to the number of games you want to analyze

# Initialize an empty dataframe to store results for the specified number of games
results_df_scorea <- data.frame(Move = character(), Score = numeric(), GameNumber = integer(), stringsAsFactors = FALSE)

# Define a function to clean timestamps
clean_timestamp <- function(timestamps) {
  gsub(".*\\[%clk\\s+([^\\}]+)\\].*", "\\1", timestamps)
}

clean_moves <- function(moves) {
  moves <- gsub("^\\.\\.\\s+", "", moves)  # Remove ..  from black moves
  moves <- gsub("\\{\\[%clk[^}]*\\]\\}", "", moves)  # Remove clock info
  moves <- gsub("^\\d+\\.\\s*|\\d+\\.\\.\\.\\s*", "", moves)  # Remove move numbers
  trimws(moves)  # Remove leading and trailing whitespace
}

# Loop through each game (up to NumberOfGames)
for (i in seq_len(min(NumberOfGames, length(all_moves)))) {
  
  # Extract moves and timestamps for the current game
  moves <- all_moves[[i]]
  timestamps <- all_timestamps[[i]]
  
  # Handle length mismatch and clean timestamps
  min_length <- min(length(moves), length(timestamps))
  cleaned_timestamps <- clean_timestamp(timestamps[1:min_length])
  
  # Create a data frame for the current game
  game_data <- data.frame(
    Move = moves[1:min_length],
    Timestamp = cleaned_timestamps,
    stringsAsFactors = FALSE
  )
  
  # Clean the moves using vectorized operations
  game_data$Move <- clean_moves(game_data$Move)
  
  # Analyze the moves for the current game using the Python function
  moves_string <- paste(unlist(game_data$Move), collapse = " ")
  
  tryCatch({
    aaresults <- py$analyze_each_move(moves_string, depth = 20, stockfish_path = stockfish_path)
    
    # Convert the analysis results to a dataframe and remove duplicates
    game_results_df <- unique(as.data.frame(do.call(rbind, aaresults), stringsAsFactors = FALSE))
    names(game_results_df) <- c("Move", "Score")
    
    # Append the results to the main dataframe, adding the game number for tracking
    game_results_df$GameNumber <- i
    results_df_scorea <- rbind(results_df_scorea, game_results_df)
    
  }, error = function(e) {
    message(paste("Error analyzing moves for game", i, ":", e$message))
  })
}

# At this point, `results_df_scorea` contains combined results for the specified number of games

# Extract and merge with zzztest for all games
zzztest_subset <- zzztest[1:nrow(results_df_scorea), ]
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)

# Initialize usernames based on game number
usernames <- ifelse(seq_along(merged_data_complete$game_number) %% 2 == 1,
                   combined_df$games$black$username[merged_data_complete$game_number],
                   combined_df$games$white$username[merged_data_complete$game_number])

# Combine the username data frame with the merged data
merged_data_complete2 <- cbind(data.frame(username = usernames, stringsAsFactors = FALSE), merged_data_complete)

# Remove the 6th column if necessary
merged_data_complete2 <- merged_data_complete2[, -6]

# Convert the 'Score' column to numeric if it's not already
merged_data_complete2$Score <- as.numeric(merged_data_complete2$Score)

# Identify even positions and multiply them by -1
even_positions <- seq(2, length(merged_data_complete2$Score), by = 2)
merged_data_complete2$Score[even_positions] <- merged_data_complete2$Score[even_positions] * -1

# Now `merged_data_complete2` contains the combined data ready for further analysis or plotting

```



```{r}


# Create a bubble plot with player information
ggplot(merged_data_complete2, aes(x = Move_Number, y = (Score), size = time_per_move, color = username)) +
  geom_point(alpha = 0.5) +
  ylim(-10,10)+
  labs(x = "Move Number", y = "Evaluation Score", size = "Time Spent (s)", color = "Player") +
  ggtitle("Bubble Plot of Move Number and Evaluation Score with Time Spent and Players") +
  theme_minimal()


#Need to adjust code for the score so that it will only increase when playing good moves and only be negative when playing bad moves. This is necessary for plotting
#Need to modify the black scores by a -1 so that they are positive, NOTE i do not know if this will work in all cases i think it will
```
#Starting the GA It works somewhat well starting port to server
```{r}

#make new dataframe for result_df that has the eval and time and move for each game
result_df <- left_join(result_df, merged_data_complete2, by = c("game_number" = "game_number")) # Adjust as necessary

result_df <- result_df %>%
  slice(1:nrow(merged_data_complete2))

library(GA)
username<-"owej9023"

result_df <- result_df %>%
  mutate(current_elo = case_when(
    V5 == username ~ V14,   # If the user is playing White, use WhiteElo
    V6 == username ~ V15,   # If the user is playing Black, use BlackElo
    TRUE ~ NA_real_                 # NA for games not involving the user
  ))

result_df <- result_df %>%
  mutate(opponentElo = case_when(
    V5 != username ~ V14,   # If the user is playing White, use WhiteElo
    V6 != username ~ V15,   # If the user is playing Black, use BlackElo
    TRUE ~ NA_real_                 # NA for games not involving the user
  ))

result_df <- result_df %>%
  mutate(game_result_numeric = case_when(
    V7 == "1-0" ~ 1,
    V7 == "0-1" ~ 0,
    V7 == "1/2-1/2" ~ 0.5,
    TRUE ~ NA_real_  # Handle unexpected cases if needed
  ))

```


```{r}

# Extract features (X) and target (y)
X <- as.matrix(result_df[, c("opponentElo", "game_result_numeric","time_per_move.y","Move_Number.y","Score.y","GameNumber.y")])  # Use opponent_elo and game_result as features
y_true <- result_df$current_elo  # Use current_elo as the target variable

# Define the fitness function (e.g., minimize MSE between predicted Elo and actual Elo)
fitness_function <- function(params, X, y_true) {
  # Predict Elo using a linear combination of features and weights (params)
  y_pred <- X %*% params
  mse <- mean((y_true - y_pred)^2)  # Mean Squared Error
  return(-mse)  # We return the negative because GA maximizes by default
}

# Run the genetic algorithm to find the optimal weights
ga_model <- ga(
  type = "real-valued",  # We're optimizing real-valued parameters
  fitness = function(params) fitness_function(params, X, y_true),
  lower = rep(-1, ncol(X)),  # Lower bounds for weights
  upper = rep(1, ncol(X)),   # Upper bounds for weights
  popSize = 500,              # Population size
  maxiter = 1000,             # Maximum number of generations
  run = 50,                  # Stop after 50 generations without improvement
  pmutation = 0.2            # Mutation probability
)

# Display the best solution
summary(ga_model)
best_weights <- ga_model@solution
best_weights

#now it becomes time to udnerstand the ouput and optimize it


```




```{r}

# Assuming 'best_weights' has been obtained from the GA

# Initialize the current state (last known values)
current_state <- as.numeric(result_df[nrow(result_df), c("opponentElo", "game_result_numeric", "time_per_move.y", "Move_Number.y", "Score.y", "GameNumber.y")])

# Function to predict future Elo
predict_future_elo <- function(current_state, weights, iterations) {
  predicted_elos <- numeric(iterations)
  
  for (i in 1:iterations) {
    # Predict Elo for the current state
    predicted_elo <- sum(current_state * weights)
    
    # Store the predicted Elo
    predicted_elos[i] <- predicted_elo
    
    # Update the current state for the next iteration
    # Here you might adjust current_state based on your rules
    # This is an example; adjust as needed based on your logic
    current_state[1] <- current_state[1] + rnorm(1, mean = 0, sd = 10)  # Simulate opponentElo change
    current_state[4] <- current_state[4] + 1  # Increment Move_Number.y
    current_state[6] <- current_state[6] + 1  # Increment GameNumber.y
    # other updates based on your model logic...
  }
  
  return(predicted_elos)
}

# Predict Elo 10 iterations into the future
future_elos <- predict_future_elo(current_state, best_weights, 20)

# Display the future Elo predictions
print(future_elos)





```

```{r}



mean_elo_difference <- function(data) {
  # Ensure that the required columns are present
  # Calculate the Elo difference for each game
  elo_differences <- abs(data$current_elo - data$opponentElo)
  
  # Calculate the mean Elo difference
  mean_difference <- mean(elo_differences, na.rm = TRUE)  # na.rm = TRUE to ignore NA values
  
  return(mean_difference)
}

# Example usage
mean_difference <- mean_elo_difference(result_df)
print(mean_difference)


```



















```{r}

# Loop through each game
for (i in seq_along(aa[1:10])) {
  game <- aa[i]
  
  # Analyze each move in the game
  aaresults <- py$analyze_each_move(game, depth=20, stockfish_path=stockfish_path)
  
  # Convert the result to a dataframe
  game_results_df <- as.data.frame(do.call(rbind, aaresults), stringsAsFactors = FALSE)
  
  # Set the column names
  names(game_results_df) <- c("Move", "Score")
  
  # Add a Move Number column
  game_results_df$`Move Number` <- 1:nrow(game_results_df)
  
  # Add a Turn column to indicate whose move it is: White or Black
  game_results_df$Turn <- ifelse(game_results_df$`Move Number` %% 2 == 1, "White", "Black")
  
  # Add Game_Number column to identify the game
  game_results_df$Game_Number <- i
  
  # Fetch usernames from combined_df for the current game
  white_username <- combined_df$games$white_username[i]
  black_username <- combined_df$games$black_username[i]
  
  # Assign the correct username based on the Turn column
  game_results_df$Username <- ifelse(game_results_df$Turn == "White", white_username, black_username)
  
  # Append the results to the main dataframe
  results_df_scorea <- rbind(results_df_scorea, game_results_df)
}

# Print the final dataframe
print(results_df_scorea)



```

```{r}
library(plotly)

# Flatten the Score column to a numeric vector
merged_data_complete$Score <- as.numeric(unlist(merged_data_complete$Score))

# Apply the logarithmic transformation
merged_data_complete$Log_Score <- log10(abs(merged_data_complete$Score) + 1) * sign(merged_data_complete$Score)


# Create a 3D scatter plot with plotly
plot_ly(data = merged_data_complete, 
        x = ~zmovenum, 
        y = ~ztime, 
        z = ~Log_Score, 
        type = 'scatter3d', 
        mode = 'markers',
        marker = list(size = 4, color = ~Log_Score, colorscale = 'Viridis')) %>%
  layout(scene = list(xaxis = list(title = "Move Number"),
                      yaxis = list(title = "Time"),
                      zaxis = list(title = "Log10(Score)")))

```

```{r}
library(dplyr)
library(ggplot2)

# Convert the Move column to a character vector if it's not already
merged_data_complete$Move <- as.character(unlist(merged_data_complete$Move))

# Filter data to keep only those facets with at least 40 points
filtered_data <- merged_data_complete %>%
  group_by(Move) %>%
  filter(n() >= 40)

# Create the plot with filtered data
ggplot(filtered_data, aes(x = time_per_move, y = Score, color = Move)) +
  geom_point() +
  facet_wrap(~Move, scales = "free_y") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 12),  # Keep x-axis title
    axis.title.y = element_text(size = 12),  # Keep y-axis title
    axis.text.x = element_blank(),            # Remove x-axis text
    strip.text = element_text(size = 10),     # Show facet labels (titles) with specified size
    legend.position = "none"                  # Remove legend
  ) +
  labs(x = "Time", y = "Score")

```

```{r}
combined_data <- list(
  `1` = list(
    list("Move" = "b3", "Timestamp" = "0:03:00"),
    list("Move" = "f6", "Timestamp" = "0:02:59.5"),
    list("Move" = "Bb2", "Timestamp" = "0:02:59.3"),
    list("Move" = "e5", "Timestamp" = "0:02:59.4"),
    list("Move" = "e3", "Timestamp" = "0:02:58.5"),
    list("Move" = "Nc6", "Timestamp" = "0:02:59.3"),
    list("Move" = "Qf3", "Timestamp" = "0:02:57.6"),
    list("Move" = "Nge7", "Timestamp" = "0:02:53.8"),
    list("Move" = "Bb5", "Timestamp" = "0:02:56"),
    list("Move" = "a6", "Timestamp" = "0:02:51.5"),
    list("Move" = "Bxc6", "Timestamp" = "0:02:55.2"),
    list("Move" = "Nxc6", "Timestamp" = "0:02:51.4"),
    list("Move" = "Ne2", "Timestamp" = "0:02:54.1"),
    list("Move" = "d5", "Timestamp" = "0:02:49.4"),
    list("Move" = "Qh5+", "Timestamp" = "0:02:52.5"),
    list("Move" = "g6", "Timestamp" = "0:02:47.1"),
    list("Move" = "Qh4", "Timestamp" = "0:02:52"),
    list("Move" = "Bg7", "Timestamp" = "0:02:45.2"),
    list("Move" = "Ng3", "Timestamp" = "0:02:48.8"),
    list("Move" = "O-O", "Timestamp" = "0:02:41.8"),
    list("Move" = "Nc3", "Timestamp" = "0:02:44.8"),
    list("Move" = "d4", "Timestamp" = "0:02:40.8"),
    list("Move" = "Na4", "Timestamp" = "0:02:42"),
    list("Move" = "dxe3", "Timestamp" = "0:02:38.1"),
    list("Move" = "fxe3", "Timestamp" = "0:02:38"),
    list("Move" = "b6", "Timestamp" = "0:02:29.8"),
    list("Move" = "O-O", "Timestamp" = "0:02:30.6"),
    list("Move" = "f5", "Timestamp" = "0:02:20.2"),
    list("Move" = "Qc4+", "Timestamp" = "0:02:28.4"),
    list("Move" = "Kh8", "Timestamp" = "0:02:17"),
    list("Move" = "Qxc6", "Timestamp" = "0:02:26.7"),
    list("Move" = "Bd7", "Timestamp" = "0:02:15.1"),
    list("Move" = "Qf3", "Timestamp" = "0:02:23.7"),
    list("Move" = "Bb5", "Timestamp" = "0:02:14.1"),
    list("Move" = "c4", "Timestamp" = "0:02:21.6"),
    list("Move" = "Bxa4", "Timestamp" = "0:02:12.5"),
    list("Move" = "bxa4", "Timestamp" = "0:02:20.4"),
    list("Move" = "Qxd2", "Timestamp" = "0:02:10.8"),
    list("Move" = "Rab1", "Timestamp" = "0:02:12.4"),
    list("Move" = "Rad8", "Timestamp" = "0:02:02.1"),
    list("Move" = "Rfd1", "Timestamp" = "0:02:03"),
    list("Move" = "Qc2", "Timestamp" = "0:01:56.6"),
    list("Move" = "a5", "Timestamp" = "0:01:47.5"),
    list("Move" = "e4", "Timestamp" = "0:01:44.6"),
    list("Move" = "Qe2", "Timestamp" = "0:01:45.2"),
    list("Move" = "Rxd1+", "Timestamp" = "0:01:35.9"),
    list("Move" = "Qxd1", "Timestamp" = "0:01:42.6"),
    list("Move" = "Qxd1+", "Timestamp" = "0:01:34.4"),
    list("Move" = "Rxd1", "Timestamp" = "0:01:40.9"),
    list("Move" = "Bxb2", "Timestamp" = "0:01:33.9"),
    list("Move" = "axb6", "Timestamp" = "0:01:37.5"),
    list("Move" = "cxb6", "Timestamp" = "0:01:32.5"),
    list("Move" = "Rb1", "Timestamp" = "0:01:36.2"),
    list("Move" = "Be5", "Timestamp" = "0:01:25.9"),
    list("Move" = "Rxb6", "Timestamp" = "0:01:33.2"),
    list("Move" = "Rc8", "Timestamp" = "0:01:24.7"),
    list("Move" = "Rb4", "Timestamp" = "0:01:25.6"),
    list("Move" = "Bc3", "Timestamp" = "0:01:20.5"),
    list("Move" = "Ra4", "Timestamp" = "0:01:23.8"),
    list("Move" = "a5", "Timestamp" = "0:01:19.4"),
    list("Move" = "Ne2", "Timestamp" = "0:01:22.6"),
    list("Move" = "Bd2", "Timestamp" = "0:01:17.5"),
    list("Move" = "Kf2", "Timestamp" = "0:01:15.7"),
    list("Move" = "Kg7", "Timestamp" = "0:01:14.9"),
    list("Move" = "Nd4", "Timestamp" = "0:01:14.8"),
    list("Move" = "Bb4", "Timestamp" = "0:01:09.4"),
    list("Move" = "a3", "Timestamp" = "0:01:12.8"),
    list("Move" = "Bc3", "Timestamp" = "0:01:07.5"),
    list("Move" = "Ke2", "Timestamp" = "0:01:10.2"),
    list("Move" = "Kh6", "Timestamp" = "0:01:03.3"),
    list("Move" = "Kd1", "Timestamp" = "0:01:05.1"),
    list("Move" = "Rb8", "Timestamp" = "0:00:56.6"),
    list("Move" = "Kc2", "Timestamp" = "0:01:03.1"),
    list("Move" = "Be1", "Timestamp" = "0:00:54.6"),
    list("Move" = "c5", "Timestamp" = "0:00:59.8"),
    list("Move" = "Rc8", "Timestamp" = "0:00:53.4"),
    list("Move" = "Rc4", "Timestamp" = "0:00:58.2"),
    list("Move" = "Bf2", "Timestamp" = "0:00:49.1"),
    list("Move" = "Rc3", "Timestamp" = "0:00:53.2"),
    list("Move" = "Kg5", "Timestamp" = "0:00:44.2"),
    list("Move" = "Kd2", "Timestamp" = "0:00:45.5"),
    list("Move" = "f4", "Timestamp" = "0:00:38.7"),
    list("Move" = "exf4+", "Timestamp" = "0:00:41.2"),
    list("Move" = "Kxf4", "Timestamp" = "0:00:38.6"),
    list("Move" = "Ne2+", "Timestamp" = "0:00:35.1"),
    list("Move" = "Ke5", "Timestamp" = "0:00:35.9"),
    list("Move" = "c6", "Timestamp" = "0:00:34.3"),
    list("Move" = "f3", "Timestamp" = "0:00:30.1"),
    list("Move" = "Kf3", "Timestamp" = "0:00:32.9"),
    list("Move" = "Nc4+", "Timestamp" = "0:00:31.6"),
    list("Move" = "Ke4", "Timestamp" = "0:00:34.5"),
    list("Move" = "Kc3", "Timestamp" = "0:00:30.8"),
    list("Move" = "Kc2", "Timestamp" = "0:00:30.5"),
    list("Move" = "Kd5", "Timestamp" = "0:00:33.8"),
    list("Move" = "g3", "Timestamp" = "0:00:26.9"),
    list("Move" = "Rxc6", "Timestamp" = "0:00:32.3"),
    list("Move" = "Rxc6", "Timestamp" = "0:00:24.6"),
    list("Move" = "Kxc6", "Timestamp" = "0:00:32.2"),
    list("Move" = "Kd3", "Timestamp" = "0:00:22.9"),
    list("Move" = "Kb5", "Timestamp" = "0:00:31"),
    list("Move" = "Nc3+", "Timestamp" = "0:00:19.6"),
    list("Move" = "Kc5", "Timestamp" = "0:00:29.3"),
    list("Move" = "Ne4+", "Timestamp" = "0:00:18.1"),
    list("Move" = "Kb5", "Timestamp" = "0:00:28.3"),
    list("Move" = "Nd6+", "Timestamp" = "0:00:16.1"),
    list("Move" = "Ka4", "Timestamp" = "0:00:27.5"),
    list("Move" = "Nc4", "Timestamp" = "0:00:15"),
    list("Move" = "Kb5", "Timestamp" = "0:00:25.3"),
    list("Move" = "g4", "Timestamp" = "0:00:14"),
    list("Move" = "h5", "Timestamp" = "0:00:24"),
    list("Move" = "gxh5", "Timestamp" = "0:00:12.7"),
    list("Move" = "gxh5", "Timestamp" = "0:00:23.9"),
    list("Move" = "h3", "Timestamp" = "0:00:11.8"),
    list("Move" = "h4", "Timestamp" = "0:00:22.8"),
    list("Move" = "Nxe3", "Timestamp" = "0:00:10.3"),
    list("Move" = "Bxe3", "Timestamp" = "0:00:21.4"),
    list("Move" = "Kxe3", "Timestamp" = "0:00:09.8"),
    list("Move" = "Ka4", "Timestamp" = "0:00:20.9"),
    list("Move" = "Kf4", "Timestamp" = "0:00:08.4"),
    list("Move" = "Kxa3", "Timestamp" = "0:00:20.8"),
    list("Move" = "Kg4", "Timestamp" = "0:00:08"),
    list("Move" = "Kb2", "Timestamp" = "0:00:20.7"),
    list("Move" = "Kxh4", "Timestamp" = "0:00:07.6"),
    list("Move" = "a4", "Timestamp" = "0:00:20.6"),
    list("Move" = "Kg5", "Timestamp" = "0:00:07.5"),
    list("Move" = "a3", "Timestamp" = "0:00:20.5"),
    list("Move" = "h4", "Timestamp" = "0:00:07.2"),
    list("Move" = "a2", "Timestamp" = "0:00:20.4"),
    list("Move" = "h5", "Timestamp" = "0:00:06.9"),
    list("Move" = "a1=Q", "Timestamp" = "0:00:20.3"),
    list("Move" = "h6", "Timestamp" = "0:00:06.5"),
    list("Move" = "Qh1", "Timestamp" = "0:00:20.1"),
    list("Move" = "Kg6", "Timestamp" = "0:00:06.2"),
    list("Move" = "Qg1+", "Timestamp" = "0:00:19.3"),
    list("Move" = "Kh7", "Timestamp" = "0:00:04.9"),
    list("Move" = "Qh2", "Timestamp" = "0:00:18.3"),
    list("Move" = "Kg7", "Timestamp" = "0:00:04.2"),
    list("Move" = "Kc3", "Timestamp" = "0:00:17.5"),
    list("Move" = "h7", "Timestamp" = "0:00:02.9"),
    list("Move" = "Qc7+", "Timestamp" = "0:00:16.7"),
    list("Move" = "Kg8", "Timestamp" = "0:00:02.2"),
    list("Move" = "Qd8+", "Timestamp" = "0:00:14.9"),
    list("Move" = "Kg7", "Timestamp" = "0:00:01.7"),
    list("Move" = "Qe7+", "Timestamp" = "0:00:14.3"),
    list("Move" = "Kg8", "Timestamp" = "0:00:01"),
    list("Move" = "Qe8+", "Timestamp" = "0:00:13.8")
  ),
  `2` = list(
    list("Move" = "e4", "Timestamp" = "0:03:00"),
    list("Move" = "c5", "Timestamp" = "0:02:59.7"),
    list("Move" = "Nf3", "Timestamp" = "0:02:59.2"),
    list("Move" = "Nc6", "Timestamp" = "0:02:58.9"),
    list("Move" = "d4", "Timestamp" = "0:02:58.0"),
    list("Move" = "cxd4", "Timestamp" = "0:02:57.4"),
    list("Move" = "Nxd4", "Timestamp" = "0:02:56.8"),
    list("Move" = "Nf6", "Timestamp" = "0:02:55.3"),
    list("Move" = "Nc3", "Timestamp" = "0:02:54.0"),
    list("Move" = "e5", "Timestamp" = "0:02:52.9"),
    list("Move" = "Nf5", "Timestamp" = "0:02:50.2"),
    list("Move" = "exf5", "Timestamp" = "0:02:48.1"),
    list("Move" = "d5", "Timestamp" = "0:02:46.6"),
    list("Move" = "Nxd4", "Timestamp" = "0:02:45.3"),
    list("Move" = "Qxd4", "Timestamp" = "0:02:44.5"),
    list("Move" = "dxc6", "Timestamp" = "0:02:42.8"),
    list("Move" = "bxc6", "Timestamp" = "0:02:41.2"),
    list("Move" = "Bd2", "Timestamp" = "0:02:40.6"),
    list("Move" = "Qd4", "Timestamp" = "0:02:39.1"),
    list("Move" = "O-O", "Timestamp" = "0:02:37.8"),
    list("Move" = "e4", "Timestamp" = "0:02:36.4"),
    list("Move" = "Bf4", "Timestamp" = "0:02:34.7"),
    list("Move" = "g6", "Timestamp" = "0:02:33.1"),
    list("Move" = "Bd3", "Timestamp" = "0:02:31.4"),
    list("Move" = "c5", "Timestamp" = "0:02:29.8"),
    list("Move" = "Nc4", "Timestamp" = "0:02:28.5"),
    list("Move" = "Be3", "Timestamp" = "0:02:27.6"),
    list("Move" = "f3", "Timestamp" = "0:02:25.2"),
    list("Move" = "Bf2", "Timestamp" = "0:02:23.9"),
    list("Move" = "Nxd6+", "Timestamp" = "0:02:22.4"),
    list("Move" = "Qxd6", "Timestamp" = "0:02:20.8"),
    list("Move" = "Bd5", "Timestamp" = "0:02:18.3"),
    list("Move" = "Qf4", "Timestamp" = "0:02:16.5"),
    list("Move" = "Bf6", "Timestamp" = "0:02:14.2"),
    list("Move" = "f4", "Timestamp" = "0:02:12.7"),
    list("Move" = "Nxf5", "Timestamp" = "0:02:10.4"),
    list("Move" = "Bxd5", "Timestamp" = "0:02:08.6"),
    list("Move" = "Rxd5", "Timestamp" = "0:02:06.5"),
    list("Move" = "Rxe5", "Timestamp" = "0:02:04.8"),
    list("Move" = "Rxe5", "Timestamp" = "0:02:03.1"),
    list("Move" = "Kf6", "Timestamp" = "0:02:01.5"),
    list("Move" = "h5", "Timestamp" = "0:01:59.8"),
    list("Move" = "Rxe1", "Timestamp" = "0:01:58.4"),
    list("Move" = "Kh7", "Timestamp" = "0:01:56.6"),
    list("Move" = "Rxe8", "Timestamp" = "0:01:54.8"),
    list("Move" = "Rxe8", "Timestamp" = "0:01:53.2"),
    list("Move" = "h4", "Timestamp" = "0:01:52.4"),
    list("Move" = "h4", "Timestamp" = "0:01:50.6"),
    list("Move" = "h3", "Timestamp" = "0:01:48.9"),
    list("Move" = "g3", "Timestamp" = "0:01:47.5"),
    list("Move" = "Kf3", "Timestamp" = "0:01:46.1"),
    list("Move" = "Kf4", "Timestamp" = "0:01:44.9"),
    list("Move" = "g5", "Timestamp" = "0:01:43.3"),
    list("Move" = "Kg3", "Timestamp" = "0:01:42.1"),
    list("Move" = "Kg4", "Timestamp" = "0:01:40.9"),
    list("Move" = "h3", "Timestamp" = "0:01:39.2"),
    list("Move" = "h2", "Timestamp" = "0:01:37.8"),
    list("Move" = "Kg3", "Timestamp" = "0:01:36.4"),
    list("Move" = "Kg5", "Timestamp" = "0:01:35.1"),
    list("Move" = "Kg5", "Timestamp" = "0:01:34.0"),
    list("Move" = "Kg7", "Timestamp" = "0:01:32.8"),
    list("Move" = "Kg7", "Timestamp" = "0:01:31.5"),
    list("Move" = "Kg8", "Timestamp" = "0:01:29.2"),
    list("Move" = "Kg9", "Timestamp" = "0:01:28.1"),
    list("Move" = "Kg9", "Timestamp" = "0:01:26.6")
  )
)



```


```{r}
convert_timestamp_to_seconds <- function(timestamp) {
  parts <- unlist(strsplit(timestamp, "[:.]"))  # Split by colon and dot
  hours <- as.numeric(parts[1])
  minutes <- as.numeric(parts[2])
  seconds <- as.numeric(parts[3])
  tenths <- as.numeric(parts[4]) / 10  # Convert tenths to seconds
  total_seconds <- (hours * 3600) + (minutes * 60) + seconds + tenths
  return(total_seconds)
}

# Loop through each game in combined_data
for (i in seq_along(combined_data)) {
  # Number of moves for the current game
  total_moves <- sum(sapply(combined_data[[i]], function(x) length(x$Timestamp)))

  # Variables for time tracking
  timepermove_player1 <- c()
  timepermove_player2 <- c()

  # Extract timestamps for the current game
  timestamps <- sapply(combined_data[[i]], function(x) x$Timestamp)

  # Convert timestamps to total time in seconds
  total_time <- sapply(timestamps, convert_timestamp_to_seconds)


  # Loop through moves, adjusting for total_time length
  for (move in 1:(length(total_time) - 2)) {  # Adjust to length - 2 for index safety
    if (is.na(total_time[move]) || is.na(total_time[move + 2])) {
      next  # Skip this iteration if any timestamp is NA
    }

    # Calculate time spent
    time_spent <- total_time[move] - total_time[move + 2]

    }

    if (move %% 2 == 1) {
      # Player 1 (White)
      timepermove_player1 <- c(timepermove_player1, time_spent)  # Convert to tenths
    } else {
      # Player 2 (Black)
      timepermove_player2 <- c(timepermove_player2, time_spent)  # Convert to tenths
    }
  }
    ```
    
```{r}

#install.packages(c('neuralnet','keras','tensorflow'),dependencies = T)
library(neuralnet)

set.seed(245)

# Split the result_df into training and test datasets
data_rows <- floor(0.80 * nrow(result_df))
train_indices <- sample(c(1:nrow(result_df)), data_rows)

# Use result_df for training and testing
train_data <- result_df[train_indices, ]
test_data <- result_df[-train_indices, ]

# Build the neural network model
model = neuralnet(
    elo_change ~year + week + month,  # Ensure these columns exist in result_df
    data = train_data,
    hidden = c(4, 2),  # Hidden layer configuration
    linear.output = FALSE
)

plot(model,rep = "best")



```


```{r}

install.packages(c('neuralnet','keras','tensorflow'),dependencies = T)

library(tidyverse)
library(neuralnet)
iris <- iris %>% mutate_if(is.character, as.factor)

set.seed(245)
data_rows <- floor(0.80 * nrow(iris))
train_indices <- sample(c(1:nrow(iris)), data_rows)
train_data <- iris[train_indices,]
test_data <- iris[-train_indices,]

model = neuralnet(
    Species~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width,
data=train_data,
hidden=c(4,2),
linear.output = FALSE
)

plot(model,rep = "best")


pred <- predict(model, test_data)
labels <- c("setosa", "versicolor", "virginca")
prediction_label <- data.frame(max.col(pred)) %>%     
mutate(pred=labels[max.col.pred.]) %>%
select(2) %>%
unlist()

table(test_data$Species, prediction_label)

check = as.numeric(test_data$Species) == max.col(pred)
accuracy = (sum(check)/nrow(test_data))*100
print(accuracy)


```


```{r}
convert_timestamp_to_seconds <- function(timestamp) {
  # Split by colon and dot
  parts <- unlist(strsplit(timestamp, "[:.]"))
  
  # Check if the timestamp includes tenths of a second
  hours <- as.numeric(parts[1])
  minutes <- as.numeric(parts[2])
  seconds <- as.numeric(parts[3])
  
  # Tenths will be NA if not present in the timestamp
  tenths <- ifelse(length(parts) == 4, as.numeric(parts[4]) / 10, 0)
  
  # Calculate total seconds
  total_seconds <- (hours * 3600) + (minutes * 60) + seconds + tenths
  return(total_seconds)
}


engine_depth <- as.integer(5)
    py$engine_depth <- engine_depth
    
    py_run_string("
import chess
import chess.engine
engine_depth = 1
move_scores = []

def analyze_each_move(moves_str, depth=engine_depth, stockfish_path='/path/to/stockfish'):
    with chess.engine.SimpleEngine.popen_uci(stockfish_path) as engine:
        board = chess.Board()
        moves = moves_str.split()
        for move in moves:
            board.push_san(move)
            info = engine.analyse(board, chess.engine.Limit(depth=depth))
            
            mate_in = info['score'].relative.mate()
            if mate_in is not None:
                if mate_in == 0:
                    score = 100  # Checkmate
                else:
                    score = 100 * (mate_in / abs(mate_in))
            else:
                score = info['score'].relative.score() / 100  # Normalize centipawn score
            
            if board.turn == chess.BLACK:
                score = -score
            
            move_scores.append((move, score))
        return move_scores
    ")
    
    num_games_to_plot <- 10000
    
    filtered_data <- combined_df %>%
      filter(games$rules == "chess", games$rated == TRUE) %>%
      tail(num_games_to_plot)
    
    total_moves <- sum(sapply(filtered_data$games$pgn, function(pgn) {
      length(str_extract_all(pgn, "\\d+:\\d+(?:\\.\\d+)?")[[1]])
    }))
    
    ### Stockfish Analysis Section (Python Integration) ###
    
    pgn_list <- strsplit(filtered_data$games$pgn, "\n\n")
    all_moves <- vector("list", length(pgn_list))
    all_timestamps <- vector("list", length(pgn_list))
    
    for (i in seq_along(pgn_list)) {
      game_pgn <- pgn_list[[i]]
      temp_aa <- extract_moves_and_timestamps(game_pgn)
      temp_aa <- separate_moves_and_timestamps(temp_aa)
      all_moves[[i]] <- temp_aa$moves
      all_timestamps[[i]] <- temp_aa$timestamps
    }

    combined_data <- vector("list", length(all_moves))
        
    for (i in seq_along(all_moves)) {
  moves <- all_moves[[i]]
  timestamps <- all_timestamps[[i]]
  
  if (is.null(moves) || is.null(timestamps) || length(moves) == 0 || length(timestamps) == 0) {
    message("Skipping game ", i, ": moves or timestamps are NULL or empty.")
    next
  }

  # Define min_length and clean timestamps before creating game_data
  min_length <- min(length(moves), length(timestamps))
  
  # Check if clean_timestamp throws an error
  cleaned_timestamps <- tryCatch({
      clean_timestamp(timestamps[1:min_length])
    },
    error = function(e) {
      message("clean_timestamp error for game ", i, ": ", e$message)
      return(rep(NA, min_length))  # Placeholder if cleaning fails
    }
  )
  
  # Create the data frame and add it to combined_data
  print(i)
  
  game_data <- data.frame(
    Move = moves[1:min_length],
    Timestamp = cleaned_timestamps,
    stringsAsFactors = FALSE
  )
  combined_data[[i]] <- game_data
}


    
    combined_data <- lapply(combined_data, function(game_data) {
      game_data$Move <- clean_moves(game_data$Move)
      game_data
    })

    
   # Initialize result storage for each game
all_timepermove_player1 <- list()
all_timepermove_player2 <- list()

# Processing move times
for (i in seq_along(combined_data)) {
  timestamps <- combined_data[[i]]$Timestamp
  
  # Skip games with less than 4 moves
  if (length(timestamps) < 4) {
    message("Skipping game ", i, " due to less than 4 moves")
    next
  }
  
  total_time <- sapply(timestamps, convert_timestamp_to_seconds)
  
  # Variables for time tracking for the current game
  timepermove_player1 <- c()
  timepermove_player2 <- c()
  
  # Main processing loop
  for (move in 1:(length(total_time) - 2)) {
    # Check for NA values before performing calculations
    if (is.na(total_time[move]) || is.na(total_time[move + 2])) {
      message("Skipping move ", move, " in game ", i, " due to NA timestamp")
      next  # Skip this iteration if any timestamp is NA
    }
    
    # Calculate time spent
    time_spent <- round(total_time[move] - total_time[move + 2], 2)
    
    # Handle negative time values if necessary
    if (time_spent < 0) {
      cat("Negative time detected for move:", move, 
          "Time spent:", time_spent, 
          "Player:", ifelse(move %% 2 == 1, "Player 1 (White)", "Player 2 (Black)"), 
          "\n")
    }
    
    # Append time spent to the appropriate player list
    if (move %% 2 == 1) {
      # Player 1 (White)
      timepermove_player1 <- c(timepermove_player1, time_spent)
    } else {
      # Player 2 (Black)
      timepermove_player2 <- c(timepermove_player2, time_spent)
    }
  }
  
  # Store results for this game
  all_timepermove_player1[[i]] <- timepermove_player1
  all_timepermove_player2[[i]] <- timepermove_player2
}

    # Combine time data into a single data frame
    zzztest <- do.call(rbind, lapply(seq_along(all_timepermove_player1), function(list_num) {
      player1_times <- all_timepermove_player1[[list_num]]
      player2_times <- all_timepermove_player2[[list_num]]
      
      combined_times <- c(player1_times, player2_times)
      move_nums <- seq_along(combined_times)
      
      data.frame(
        time_per_move = combined_times,
        move_number = move_nums,
        game_number = list_num,
        time_class = rep(filtered_data$games$time_class[list_num], length(combined_times))
      )
    }))
    
    # Define the path to the Stockfish engine executable
    stockfish_path <- "stockfish-windows-x86-64-avx2"
    
    # Initialize an empty data frame for storing move and score information
    results_df_scorea <- data.frame(Move = character(), Score = numeric(), stringsAsFactors = FALSE)
    
    # Initialize an empty data frame for storing game results
    game_results_df <- data.frame()
    
    # Loop through each game to analyze the moves
    for (i in 1:num_games_to_plot) {
      # Concatenate all the moves of the current game into a single string
      moves_string <- paste(unlist(combined_data[[i]][["Move"]]), collapse = " ")
      
      # Analyze each move using the Stockfish engine and retrieve scores for each move
      aaresults <- py$analyze_each_move(moves_string, depth = engine_depth, stockfish_path = stockfish_path)
      
      # Convert the analysis results to a data frame
      current_game_df <- as.data.frame(do.call(rbind, aaresults), stringsAsFactors = FALSE)
      
      # Add a game ID column to the current game data
      current_game_df$game_id <- i
      
      # Remove any duplicate rows from the current game's results
      unique_game_df <- current_game_df[!duplicated(current_game_df), ]
      
      # Append the results to the overall game results data frame
      game_results_df <- rbind(game_results_df, unique_game_df)
    }
    
    # Rename the columns of the current game data frame to "Move" and "Score"
    names(current_game_df) <- c("Move", "Score")
    
    # Append the current game data frame to the results data frame
    results_df_scorea <- rbind(results_df_scorea, current_game_df)
    
    # Take a subset of `zzztest` based on the smaller number of rows between `zzztest` and `results_df_scorea`
    zzztest_subset <- zzztest[1:min(nrow(zzztest), nrow(results_df_scorea)), ]
    
    # Match the number of rows between `zzztest` and `results_df_scorea`
    results_df_scorea <- results_df_scorea[1:min(nrow(results_df_scorea), nrow(zzztest)), ]
    
    # Combine `zzztest_subset` and `results_df_scorea` into a single data frame
    merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
    
    # Assign usernames based on the game number, alternating between black and white players
    usernames <- ifelse(seq_along(merged_data_complete$game_number) %% 2 == 1,
                        combined_df$black$username[merged_data_complete$game_number],
                        combined_df$white$username[merged_data_complete$game_number])
    
    # Add the usernames to the merged data and convert the Score column to numeric
    merged_data_complete2 <- cbind(data.frame(username = usernames, stringsAsFactors = FALSE), merged_data_complete)
    merged_data_complete2$Score <- as.numeric(merged_data_complete2$Score)
    
    # Flip the sign of the scores for even moves (i.e., moves by Black)
    even_positions <- seq(2, length(merged_data_complete2$Score), by = 2)
    merged_data_complete2$Score[even_positions] <- merged_data_complete2$Score[even_positions] * -1
    
    # Filter the data to only include rows where the username matches the input username
    merged_data_complete2 <- merged_data_complete2[merged_data_complete2$username == input$username, ]
    merged_data_complete2(merged_data_complete2)

    
```
    