next
}
timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
moves <- c(moves, move)
timestamps <- c(timestamps, timestamp)
}
move_string <- paste(moves, collapse = " ")
timestamp_dict <- as.list(timestamps)
return(list(moves = moves, timestamps = timestamp_dict))
}
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
library(lubridate)
library(hms)  # For handling time without dates
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
for (pgn in combined_df$games$pgn) {
count <- count + 1
# Extract moves and timestamps from the PGN data
extracted_data <- extract_moves_and_timestamps(pgn)
separated_data <- separate_moves_and_timestamps(extracted_data)
# Extract the moves and timestamps
moves <- separated_data$moves
timestamps <- separated_data$timestamps
# Initialize a list to store time per move within the outer loop
timepermoveinterior <- list()
movesinterior <- list()
# Initialize the previous time with the starting time control in seconds
# Convert time control (e.g., 600, 180) to an hms object
initial_time <- as.numeric(combined_df$games$time_control[count])
previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
# Loop through timestamps to calculate time per move
for (i in seq_along(timestamps)) {
# Convert the current timestamp to an hms object
current_time <- as_hms(timestamps[[i]])
# Calculate the time per move in seconds (including milliseconds)
time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
# Round the time per move to 1 decimal place and store it
time_per_move <- round(time_per_move, 1)
timepermoveinterior <- c(timepermoveinterior, time_per_move)
# Store the move
movesinterior <- c(movesinterior, moves[i])
# Update previous time for the next iteration
previous_time <- current_time
}
# Add time_per_move, move, and time_class for the current game to the respective lists
timepermove <- c(timepermove, list(timepermoveinterior))
moves_list <- c(moves_list, list(movesinterior))
}
# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
inner_list <- timepermove[[list_num]]
move_list <- moves_list[[list_num]]
if (length(inner_list) > 0) {
df <- data.frame(
time_per_move = unlist(inner_list),
Move_Number = seq_along(inner_list),
game_number = list_num,
time_class = rep(filtered_data$games$time_class[list_num], length(inner_list)),
Move = unlist(move_list)
)
return(df)
} else {
return(NULL)
}
}))
View(zzztest)
#time per move is fucked rn
#adjust score to reflect user vs op
# Extract rows from zzztest
extractlength<-length(results_df_scorea)
zzztest_subset <- zzztest[1:extractlength, ]
# Combine the extracted columns with the other data frame
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
count <- 0
usernames <- list()  # Use a list to collect usernames
for (gamenumber in merged_data_complete$game_number) {
count <- count + 1
# Check if count is odd or even
if (count %% 2 == 1) {
# Add black player's username for odd counts
usernames[[count]] <- combined_df$games$black$username[gamenumber]
} else {
# Add white player's username for even counts
usernames[[count]] <- combined_df$games$white$username[gamenumber]
}
}
# Convert the list to a data frame
username_df <- data.frame(username = unlist(usernames), stringsAsFactors = FALSE)
merged_data_complete2<-cbind(username_df,merged_data_complete)
View(merged_data_complete2)
#time per move is fucked rn
#adjust score to reflect user vs op
# Extract rows from zzztest
extractlength<-length(results_df_scorea)
zzztest_subset <- zzztest[1:extractlength, ]
# Combine the extracted columns with the other data frame
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
count <- 0
usernames <- list()  # Use a list to collect usernames
for (gamenumber in merged_data_complete$game_number) {
count <- count + 1
# Check if count is odd or even
if (count %% 2 == 1) {
# Add black player's username for odd counts
usernames[[count]] <- combined_df$games$black$username[gamenumber]
} else {
# Add white player's username for even counts
usernames[[count]] <- combined_df$games$white$username[gamenumber]
}
}
# Convert the list to a data frame
username_df <- data.frame(username = unlist(usernames), stringsAsFactors = FALSE)
merged_data_complete2<-cbind(username_df,merged_data_complete)
#time per move is fucked rn
#adjust score to reflect user vs op
# Extract rows from zzztest
extractlength<-length(results_df_scorea)
zzztest_subset <- zzztest[1:extractlength, ]
# Combine the extracted columns with the other data frame
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
# Initialize lists and counters
count <- 0
usernames <- list()  # Use a list to collect usernames
# Loop through each game number in the merged data
for (i in seq_along(merged_data_complete$game_number)) {
count <- count + 1
# Extract the game number for current iteration
gamenumber <- merged_data_complete$game_number[i]
# Check if the count is odd or even to alternate between black and white
if (count %% 2 == 1) {
# For odd counts, assign black player's username
usernames[[count]] <- combined_df$games$black$username[gamenumber]
} else {
# For even counts, assign white player's username
usernames[[count]] <- combined_df$games$white$username[gamenumber]
}
}
# Convert the list of usernames to a data frame
username_df <- data.frame(username = unlist(usernames), stringsAsFactors = FALSE)
# Combine the username data frame with the merged data
merged_data_complete2 <- cbind(username_df, merged_data_complete)
print(username_df)
View(username_df)
extractlength<-length(results_df_scorea)
zzztest_subset <- zzztest[1:extractlength, ]
# Combine the extracted columns with the other data frame
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
View(merged_data_complete)
View(merged_data_complete2)
View(zzztest_subset)
#time per move is fucked rn
#adjust score to reflect user vs op
# Extract rows from zzztest
extractlength<-length(results_df_scorea)
zzztest_subset <- zzztest[1:extractlength, ]
# Combine the extracted columns with the other data frame
merged_data_complete <- cbind(zzztest, results_df_scorea)
merged_data_complete <- cbind(zzztest[1:26], results_df_scorea)
zzztest_subset <- zzztest[1:26, ]
merged_data_complete <- cbind(zzztest_subset, results_df_scorea)
extractlength
merged_data_complete2 <- cbind(username_df, merged_data_complete)
View(timestamps)
extract_moves_and_timestamps <- function(pgn) {
lines <- unlist(strsplit(pgn, "\n"))
moves_line <- lines[length(lines)]
matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
moves <- unlist(matches)
moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
return(moves_cleaned)
}
separate_moves_and_timestamps <- function(data) {
moves <- c()
timestamps <- list()
for (entry in data) {
if (grepl("^\\d+\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
} else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
} else {
next
}
timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
moves <- c(moves, move)
timestamps <- c(timestamps, timestamp)
}
move_string <- paste(moves, collapse = " ")
timestamp_dict <- as.list(timestamps)
return(list(moves = moves, timestamps = timestamp_dict))
}
library(lubridate)
library(hms)  # For handling time without dates
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
for (pgn in combined_df$games$pgn) {
count <- count + 1
# Extract moves and timestamps from the PGN data
extracted_data <- extract_moves_and_timestamps(pgn)
separated_data <- separate_moves_and_timestamps(extracted_data)
# Extract the moves and timestamps
moves <- separated_data$moves
timestamps <- separated_data$timestamps
# Initialize a list to store time per move within the outer loop
timepermoveinterior <- list()
movesinterior <- list()
# Initialize the previous time with the starting time control in seconds
initial_time <- as.numeric(combined_df$games$time_control[count])
previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
# Loop through timestamps to calculate time per move
for (i in seq_along(timestamps)) {
# Convert the current timestamp to an hms object
current_time <- as_hms(timestamps[[i]])
# Ensure timestamps are correctly parsed
if (is.na(current_time)) {
warning(paste("Timestamp parsing failed for move", i, "in game", count))
next
}
# Calculate the time per move in seconds (including milliseconds)
time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
# Ensure no negative times; if negative, set to zero or handle increment
if (time_per_move < 0) {
# Option 1: Set negative times to zero
time_per_move <- 0
# Option 2: Add increment time to current_time (if increment is known)
# increment <- 2  # Replace with actual increment value if available
# previous_time <- previous_time + increment
# time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
}
# Round the time per move to 1 decimal place and store it
time_per_move <- round(time_per_move, 1)
timepermoveinterior <- c(timepermoveinterior, time_per_move)
# Store the move
movesinterior <- c(movesinterior, moves[i])
# Update previous time for the next iteration
previous_time <- current_time
}
# Add time_per_move, move, and time_class for the current game to the respective lists
timepermove <- c(timepermove, list(timepermoveinterior))
moves_list <- c(moves_list, list(movesinterior))
}
extract_moves_and_timestamps <- function(pgn) {
lines <- unlist(strsplit(pgn, "\n"))
moves_line <- lines[length(lines)]
matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
moves <- unlist(matches)
moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
return(moves_cleaned)
}
separate_moves_and_timestamps <- function(data) {
moves <- c()
timestamps <- list()
for (entry in data) {
if (grepl("^\\d+\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
} else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
} else {
next
}
timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
moves <- c(moves, move)
timestamps <- c(timestamps, timestamp)
}
move_string <- paste(moves, collapse = " ")
timestamp_dict <- as.list(timestamps)
return(list(moves = moves, timestamps = timestamp_dict))
}
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
library(lubridate)
library(hms)  # For handling time without dates
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
for (pgn in combined_df$games$pgn) {
count <- count + 1
# Extract moves and timestamps from the PGN data
extracted_data <- extract_moves_and_timestamps(pgn)
separated_data <- separate_moves_and_timestamps(extracted_data)
# Extract the moves and timestamps
moves <- separated_data$moves
timestamps <- separated_data$timestamps
# Initialize a list to store time per move within the outer loop
timepermoveinterior <- list()
movesinterior <- list()
# Initialize the previous time with the starting time control in seconds
# Convert time control (e.g., 600, 180) to an hms object
initial_time <- as.numeric(combined_df$games$time_control[count])
previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
# Loop through timestamps to calculate time per move
for (i in seq_along(timestamps)) {
# Convert the current timestamp to an hms object
current_time <- as_hms(timestamps[[i]])
print(current_time)
# Calculate the time per move in seconds (including milliseconds)
time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
# Round the time per move to 1 decimal place and store it
time_per_move <- round(time_per_move, 1)
timepermoveinterior <- c(timepermoveinterior, time_per_move)
# Store the move
movesinterior <- c(movesinterior, moves[i])
# Update previous time for the next iteration
previous_time <- current_time
}
# Add time_per_move, move, and time_class for the current game to the respective lists
timepermove <- c(timepermove, list(timepermoveinterior))
moves_list <- c(moves_list, list(movesinterior))
}
extract_moves_and_timestamps <- function(pgn) {
lines <- unlist(strsplit(pgn, "\n"))
moves_line <- lines[length(lines)]
matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
moves <- unlist(matches)
moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
return(moves_cleaned)
}
separate_moves_and_timestamps <- function(data) {
moves <- c()
timestamps <- list()
for (entry in data) {
if (grepl("^\\d+\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
} else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
} else {
next
}
timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
moves <- c(moves, move)
timestamps <- c(timestamps, timestamp)
}
move_string <- paste(moves, collapse = " ")
timestamp_dict <- as.list(timestamps)
return(list(moves = moves, timestamps = timestamp_dict))
}
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
library(lubridate)
library(hms)  # For handling time without dates
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
for (pgn in combined_df$games$pgn[1]) {
count <- count + 1
# Extract moves and timestamps from the PGN data
extracted_data <- extract_moves_and_timestamps(pgn)
separated_data <- separate_moves_and_timestamps(extracted_data)
# Extract the moves and timestamps
moves <- separated_data$moves
timestamps <- separated_data$timestamps
# Initialize a list to store time per move within the outer loop
timepermoveinterior <- list()
movesinterior <- list()
# Initialize the previous time with the starting time control in seconds
# Convert time control (e.g., 600, 180) to an hms object
initial_time <- as.numeric(combined_df$games$time_control[count])
previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
# Loop through timestamps to calculate time per move
for (i in seq_along(timestamps)) {
# Convert the current timestamp to an hms object
current_time <- as_hms(timestamps[[i]])
print(current_time)
# Calculate the time per move in seconds (including milliseconds)
time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
# Round the time per move to 1 decimal place and store it
time_per_move <- round(time_per_move, 1)
timepermoveinterior <- c(timepermoveinterior, time_per_move)
# Store the move
movesinterior <- c(movesinterior, moves[i])
# Update previous time for the next iteration
previous_time <- current_time
}
# Add time_per_move, move, and time_class for the current game to the respective lists
timepermove <- c(timepermove, list(timepermoveinterior))
moves_list <- c(moves_list, list(movesinterior))
}
# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
inner_list <- timepermove[[list_num]]
move_list <- moves_list[[list_num]]
if (length(inner_list) > 0) {
df <- data.frame(
time_per_move = unlist(inner_list),
Move_Number = seq_along(inner_list),
game_number = list_num,
time_class = rep(filtered_data$games$time_class[list_num], length(inner_list)),
Move = unlist(move_list)
)
return(df)
} else {
return(NULL)
}
}))
View(timestamps)
extract_moves_and_timestamps <- function(pgn) {
lines <- unlist(strsplit(pgn, "\n"))
moves_line <- lines[length(lines)]
matches <- regmatches(moves_line, gregexpr("\\d+\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]|\\d+\\.\\.\\.\\s+[^{}]+\\{\\[%clk\\s+[^\\}]+\\]", moves_line))
moves <- unlist(matches)
moves_cleaned <- gsub("\\{\\[%clk\\s+([^\\}]+)\\]\\}", " \\1", moves)
return(moves_cleaned)
}
separate_moves_and_timestamps <- function(data) {
moves <- c()
timestamps <- list()
for (entry in data) {
if (grepl("^\\d+\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\s+([^{}]+)", "\\1", entry))
} else if (grepl("^\\d+\\.\\.\\.\\s+", entry)) {
move <- sub("\\{\\[%clk\\s+([^\\}]+)\\]", "", sub("\\d+\\.\\.\\.\\s+([^{}]+)", "\\1", entry))
} else {
next
}
timestamp <- sub(".*\\{\\[%clk\\s+([^\\}]+)\\]", "\\1", entry)
moves <- c(moves, move)
timestamps <- c(timestamps, timestamp)
}
move_string <- paste(moves, collapse = " ")
timestamp_dict <- as.list(timestamps)
return(list(moves = moves, timestamps = timestamp_dict))
}
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
library(lubridate)
library(hms)  # For handling time without dates
# Initialize lists and counters
timepermove <- list()
moves_list <- list()
count <- 0
# Loop through each game in combined_df
for (pgn in combined_df$games$pgn[1]) {
count <- count + 1
# Extract moves and timestamps from the PGN data
extracted_data <- extract_moves_and_timestamps(pgn)
separated_data <- separate_moves_and_timestamps(extracted_data)
# Extract the moves and timestamps
moves <- separated_data$moves
timestamps <- separated_data$timestamps
# Initialize a list to store time per move within the outer loop
timepermoveinterior <- list()
movesinterior <- list()
# Initialize the previous time with the starting time control in seconds
# Convert time control (e.g., 600, 180) to an hms object
initial_time <- as.numeric(combined_df$games$time_control[count])
previous_time <- as_hms(initial_time)  # Use the starting time control for the first move
# Loop through timestamps to calculate time per move
for (i in seq_along(timestamps)) {
# Convert the current timestamp to an hms object
current_time <- as_hms(timestamps[[i]])
print(current_time)
# Calculate the time per move in seconds (including milliseconds)
time_per_move <- as.numeric(difftime(previous_time, current_time, units = "secs"))
print(time_per_move)
# Round the time per move to 1 decimal place and store it
time_per_move <- round(time_per_move, 1)
timepermoveinterior <- c(timepermoveinterior, time_per_move)
# Store the move
movesinterior <- c(movesinterior, moves[i])
# Update previous time for the next iteration
previous_time <- current_time
}
# Add time_per_move, move, and time_class for the current game to the respective lists
timepermove <- c(timepermove, list(timepermoveinterior))
moves_list <- c(moves_list, list(movesinterior))
}
# Combine all games into zzztest dataframe
zzztest <- do.call(rbind, lapply(seq_along(timepermove), function(list_num) {
inner_list <- timepermove[[list_num]]
move_list <- moves_list[[list_num]]
if (length(inner_list) > 0) {
df <- data.frame(
time_per_move = unlist(inner_list),
Move_Number = seq_along(inner_list),
game_number = list_num,
time_class = rep(filtered_data$games$time_class[list_num], length(inner_list)),
Move = unlist(move_list)
)
return(df)
} else {
return(NULL)
}
}))
shiny::runApp('GitHub/ChessWebpage')
runApp('GitHub/ChessWebpage')
runApp('GitHub/ChessWebpage')
runApp('GitHub/ChessWebpage')
setwd("~/GitHub/ChessWebpage")
runApp()
runApp()
